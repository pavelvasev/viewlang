Параметры, которые подразумевают анимацию, несут в себе ParamAnimation.

Это параметры:
* Param и как следствие 
 * ComboBoxParam, 
 * RadiusParam, OpacityParam

* Не содержат в себе анимаций
* CheckBoxParam -- а почему?
* FileParam

ParamAnimation - наполняет структуру rootScene.gatheredParams собой.
также каждое ParamAnimation несет в себе ParamOsc как безымянный под-объект

gatheredParams используются:

1 ************* Movie 
- при наполнении списка параметров для пользователя - params[i].target.text - во время открытия диалога
- updateminmax - корректировка текстовых значений диалога
- gogo - запуск анимации
При этом нигде тут не используется собственно ParamAnimation, везде идет отсылка на target.

2 ************* ParamOscRoot
- при получении сообщения - находит в списке gatheredParams информацию о ParamAnimation и 
использует ее propertyWrite-значение.
// исторически propertyWrite появилось от камер


=> ParamAnimation используется только в Param, 
и несет в себе ParamOsc. ParamOsc вынесен видимо отдельно, чтобы можно было управлять камерой
по OSC, не "захломляя" список анимации. Ну и вообще это были отдельные изначально сущности.
ParamAnimation также вынесен видимо отдельно, чтобы не захламлять Param.. Ну и формально не только
анимацию параметров оно может осуществлять, а вообще всего чего угодно.

++++++++++++++++++++++++

ParamOsc - реагирует на изменение мониторенного параметра, т.е. подцепляется к объекту к property+Changed и реагирует посылкой сообщения в порт, созданный ранее в ParamOscRoot.

ParamOscRoot - создается только в корневой сцене. При выставлении флага enabled
открывает коннект к сокету osc-сервера. При получении сообщений от osc-сервера опрашивает 
gatheredParams, находит информацию и пишет.

Вообще очень странно, что paramOsc опирается на хранилище параметров из области анимации.

++++++++++++++++++++++++

Выяснение scope.

Создан объект ScopeCalculator для вычисления глобальной (для управления по osc- и url-) имен переменных.

// Выход 1: scopeName - строка, текущий полный scope, сделанный уникальным (учли возможное дублирование).

// Вход 2: name
// Выход 2: globalName - имя с добавлением scopeName и с учетом повторного возможного дублирования (например когда scopeName пуст).

//////////////////////////////
Для работы нескольких приложений одновременно, у которых одинаковые имена параметров, нужны scopes.

1. Умеет вычислять текущий scope класс ScopeCalculator.qml
Он опирается на переменную scopeName, которую можно задать где угодно. Подразумевается что ей будут маркироваться объекты Scene.

2. Когда используем ParamUrlHashing то рядом ставим ScopeCalculator и он помогает вычислять глобальное имя. См CheckBoxParam для примера.

///////////////////////////////

ScopeCalculator используется в
CheckBoxParam
FileParam
Param
ParamScopedUrlHashing


++++++++++++++++++++++++

ParamUrlHashing

преобразует значения параметров url-адрес и обратно.
На вход берет name. По факту ему туда подаем уже преобразованное в scope-режим этот name.

ParamUrlHashing используется во всех видах параметров, плюс в сцене для сохранения позиции камеры.

------------------------------------

Таким образом, каждый уважающий себя параметр должОн
- содержать поля общего вида
    property var text //: title тут еще выясняю...
    property var title
    property var value

- для анимации и osc:
    property var min:0
    property var max:10
    property var step:1

- property var values - список возможных значений в режиме комбо-бокса
  при этом value начинает играть роль индекса (странно, правда?)
   
- ParamUrlHashing для взаимодействия с урлем. См. пример в
- ScopeCalculcator для вычисления scope
- ParamAnimation для участия в анимации и в OSC-событиях
- "может" теоретически содержать и ParamOsc

