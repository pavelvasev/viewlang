// Пример того, как имея ThreeJS-сущность превратить ее в Viewlang-объект

SceneObjectThreeJs { // используем спец. базовый класс
    id: obj

    property string text: "Рыба ела мясо, и считала 123"

    onColorChanged: makeLater(this);

    /////////////////// Создание Three-js сущностей по требованию -- когда viewlang вызывает функцию make3d
    
    /* вызывается для преобразования текущего qml-объекта в threejs-сущности
       повторные вызовы означают что объект необходимо пере-преобразовать заново (не забыв почистить то что было создано ранее)
       Доступные для использования переменные объектов threejs:
       
       * threejs.scene
       * threejs.sceneControl
       * threejs.camera
       * threejs.renderer

       Также уже загружена библиотека jQuery. 
    */

    function make3d() {
      prepare();
      //return;

      var tx = obj.text;
      tx = "X";

      this.context1.clearRect( 0,0,500,500 );
		  if (tx.length > 0) {
		    var height = 20;
	      this.context1.font = "Bold " + height + "px Georgia"; // Times New Roman";
				var metrics = context1.measureText(tx);
				var width = metrics.width;
				console.log( "so width=",width);
				
				//this.canvas1.width = width + 9;
				//this.canvas1.height = height + 9;
				
//				this.canvas1.width = 256;
//        this.canvas1.height = 256;
				
				this.context1.fillStyle = "black";
				this.context1.fillRect( 1,1, width+8,height+8);

				this.context1.fillStyle = "rgba(255,255,255,0.95)"; // white filler
				this.context1.fillRect( 3,3, width+4,height+4 );

				this.context1.fillStyle = "rgba(0,0,0,1)"; // text color
				this.context1.textAlign = "center";
        this.context1.textBaseline = "middle";
				//this.context1.fillText( "X", 5, height );
				this.context1.fillText( tx, width/2, height/2 +5 );


			}

      this.texture1.needsUpdate = true;
    }

    function prepare() {
      if (this.sceneObject) return;

      // view-source:http://stemkoski.github.io/Three.js/Mouse-Tooltip.html

	    // create a canvas element
	    this.canvas1 = document.createElement('canvas');
//	    this.canvas1.width = 100;
//	    this.canvas1.height = 100;
	    this.context1 = canvas1.getContext('2d');
      this.context1.fillStyle = "rgba(0,255,0,1)";
  	  this.context1.fillRect(0,0,100,100);
/*
  	  var ctx = this.context1;
  	  ctx.beginPath();
ctx.moveTo(0,0);
ctx.lineTo(50,50);
ctx.stroke();
*/

     	// canvas contents will be used for a texture
	    this.texture1 = new THREE.Texture(this.canvas1) 
	    this.texture1.minFilter = THREE.LinearFilter;
	    this.texture1.needsUpdate = true;
	
	    ////////////////////////////////////////
	    //texture1.wrapS = true;
	    //texture1.wrapT = true;
	    //texture1.offset.set( -0.25, 0.25 );
	    //texture1.offset.set( -0.25, 0 );
	    //texture1.repeat.set( 2, 2 );
	
	    var spriteMaterial = new THREE.SpriteMaterial( { map: this.texture1 } );
	    //spriteMaterial.map.offset.set( -0.5, -0.5 );
	    //useScreenCoordinates: true , alignment: THREE.SpriteAlignment.topLeft
	    // первая -0.25 это по центру
	    //spriteMaterial.map.offset.set( -0.25, 0.25 );
	
	    this.sceneObject = new THREE.Sprite( spriteMaterial );
	    //this.sceneObject.scale.set(5,2.5,1.0);
	    //this.sceneObject.scale.set( 2, 1, 1 );
	    this.sceneObject.visible = visible;

	    threejs.scene.add( this.sceneObject );
      make3dbase();
    }
    
    function clear() {
      if (this.sceneObject) {
        scene.remove( this.sceneObject );
        if (this.sceneObject.geometry) this.sceneObject.geometry.dispose();
        if (this.sceneObject.material) this.sceneObject.material.dispose();
      }
      
      this.context1 = undefined;
      this.texture1 = undefined;
      this.canvas1 = undefined;
      
      this.sceneObject = undefined;
    }

    //////////////////////////////////////

    function somethingToColor( theColorData )
    {
      return theColorData.length && theColorData.length >= 3 ? new THREE.Color( theColorData[0], theColorData[1], theColorData[2] ) : new THREE.Color(theColorData);
    }

    Component.onCompleted: {
    }

    Component.onDestruction: {
      // место очистки - созданных dom и threejs объектов
      clear();
    }
}
