// Пример того, как имея ThreeJS-сущность превратить ее в Viewlang-объект

SceneObjectThreeJs { // используем спец. базовый класс
    id: obj

    property string text: ""

    function repaint() {
      console.log("obj.center=",obj.center);
      if (needmake()) return;

      var tx = obj.text;

  	  //this.context1.clearRect(0,0,640,480);
		  if (tx.length > 0) {
				var metrics = context1.measureText(tx);
				var width = metrics.width;
				var height = 20;

				this.context1.fillStyle = "rgba(0,0,0,0.95)"; // black border
				this.context1.fillRect( 0,0, width+8,height+8);
				this.context1.fillStyle = "rgba(255,255,255,0.95)"; // white filler
				this.context1.fillRect( 2,2, width+4,height+4 );
				this.context1.fillStyle = "rgba(0,0,0,1)"; // text color
				this.context1.fillText( tx, 4, height );
			}

      this.texture1.needsUpdate = true;
    }

    onColorChanged: repaint(); // makeLater(this);

    /////////////////// Создание Three-js сущностей по требованию -- когда viewlang вызывает функцию make3d
    
    /* вызывается для преобразования текущего qml-объекта в threejs-сущности
       повторные вызовы означают что объект необходимо пере-преобразовать заново (не забыв почистить то что было создано ранее)
       Доступные для использования переменные объектов threejs:
       
       * threejs.scene
       * threejs.sceneControl
       * threejs.camera
       * threejs.renderer

       Также уже загружена библиотека jQuery. 
    */

    function needmake() {
      if (!this.sceneObject) { make3d(); return true; }
      return false;
    }

    function make3d() {
      // проверка что свойства установлены (в qmlweb на ранних этапах они могут содержать undefined)
      clear(); // очистка ранее созданного
      
      // /////////////////////////////////  поехали
      // view-source:http://stemkoski.github.io/Three.js/Mouse-Tooltip.html

	    // create a canvas element
	    this.canvas1 = document.createElement('canvas');
	    this.context1 = canvas1.getContext('2d');
	    this.context1.font = "Bold 20px Arial";
	    var c = somethingToColor( color ); 
	    //obj.context1.fillStyle = c; // "rgba(0,0,0,0.95)";
      //obj.context1.fillText( obj.text, 0, 20);
    
     	// canvas contents will be used for a texture
	    this.texture1 = new THREE.Texture(this.canvas1) 
	
	    ////////////////////////////////////////
	
	    var spriteMaterial = new THREE.SpriteMaterial( { map: this.texture1 } );
	    //spriteMaterial.map.offset.set( -0.5, -0.5 );
	    //useScreenCoordinates: true , alignment: THREE.SpriteAlignment.topLeft
	
	    this.sceneObject = new THREE.Sprite( spriteMaterial );
	    this.sceneObject.scale.set(20,10,1.0);
	    this.sceneObject.visible = visible;
	    

	    threejs.scene.add( this.sceneObject );
      make3dbase();

      repaint();
    }
    
    function clear() {
      if (this.sceneObject) {
        scene.remove( this.sceneObject );
        if (this.sceneObject.geometry) this.sceneObject.geometry.dispose();
        if (this.sceneObject.material) this.sceneObject.material.dispose();
      }
      
      this.context1 = undefined;
      this.texture1 = undefined;
      this.canvas1 = undefined;
      
      this.sceneObject = undefined;
    }

    //////////////////////////////////////

    function somethingToColor( theColorData )
    {
      return theColorData.length && theColorData.length >= 3 ? new THREE.Color( theColorData[0], theColorData[1], theColorData[2] ) : new THREE.Color(theColorData);
    }

    Component.onCompleted: {
    }

    Component.onDestruction: {
      // место очистки - созданных dom и threejs объектов
      clear();
    }
}
